<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Vico 3D visualization</title>
    <style>
        body {
            margin: 0;
        }
    </style>
</head>
<body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r126/three.min.js"></script>
<script src="/js/OBJLoader.js"></script>
<script src="/js/MTLLoader.js"></script>
<script src="/js/OrbitControls.js"></script>
<script src="/js/Capsule.js"></script>
<script src="/js/Stats.js"></script>
<script src="/js/Frame.js"></script>
<script src="/js/GeometryParser.js"></script>
<script>

    (function () {

        const entities = {}

        const stats = new Stats()
        document.body.appendChild(stats.dom)

        const scene = new THREE.Scene();
        scene.background = new THREE.Color("aliceblue")
        scene.add(new THREE.AmbientLight())

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        //camera.position.z = 10;

        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);

        const socket = new WebSocket('ws://localhost:8000/visual');

        socket.addEventListener('open', function (event) {
            console.log("open")
            send(socket, "subscribe")
        });

        socket.addEventListener('close', function (event) {
            console.log("close")
        });

        document.addEventListener('keydown', function (event) {
            let key = event.key
            send(socket, "keyPressed", key)
        })

        function setup(data) {
            for (const key in data) {
                let value = data[key]

                if (value.tag === "camera") {
                    camera.position.x = value.position.x
                    camera.position.y = value.position.y
                    camera.position.z = value.position.z
                    controls.update()
                    continue
                }

                let obj = new THREE.Object3D()
                obj.name = key
                if (value.geometry) {
                    obj.visible = value.geometry.visible

                    let mat = new THREE.MeshBasicMaterial({
                        color: value.geometry.color,
                        wireframe: value.geometry.wireframe
                    })
                    if (value.geometry.opacity < 1) {
                        mat.opacity = value.geometry.opacity
                        mat.transparent = true
                    }
                    createMesh(value.geometry.shape, mat, function (mesh) {
                        mesh.matrixAutoUpdate = false
                        if (value.geometry.offset) {
                            mesh.matrix.elements = value.geometry.offset
                        }
                        obj.add(mesh)
                    })
                }
                scene.add(obj)
                entities[key] = obj
            }
            update(data)
        }

        function update(data) {
            for (const key in data) {
                let o = entities[key]
                if (o) {
                    let value = data[key]
                    o.position.x = value.position.x
                    o.position.y = value.position.y
                    o.position.z = value.position.z
                }
            }
        }

        socket.addEventListener('message', function (event) {
            let payload = JSON.parse(event.data)
            const type = payload.type

            switch (type) {
                case "setup":
                    setup(payload.data)
                    break
                case "update":
                    update(payload.data)
                    stats.update()
                    break
            }

        });

        window.addEventListener('resize', onWindowResize, false);

        function onWindowResize() {

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);

        }

        const animate = function () {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        };

        animate();


    })()

</script>
</body>
</html>
